{
  "version": 3,
  "sources": ["../../../../../node_modules/projects/angular-jwt/src/lib/jwtoptions.token.ts", "../../../../../node_modules/projects/angular-jwt/src/lib/jwthelper.service.ts", "../../../../../node_modules/projects/angular-jwt/src/lib/jwt.interceptor.ts", "../../../../../node_modules/projects/angular-jwt/src/lib/angular-jwt.module.ts", "../../../../../node_modules/projects/angular-jwt/src/index.ts", "../../../../../node_modules/projects/angular-jwt/src/auth0-angular-jwt.ts"],
  "sourcesContent": ["import { InjectionToken } from '@angular/core';\n\nexport const JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n", "import { HttpRequest } from '@angular/common/http';\n/* eslint-disable no-bitwise */\n\nimport { Injectable, Inject } from '@angular/core';\nimport { JWT_OPTIONS } from './jwtoptions.token';\n\n@Injectable()\nexport class JwtHelperService {\n  tokenGetter: () => string | Promise<string>;\n\n  constructor(@Inject(JWT_OPTIONS) config: any = null) {\n    this.tokenGetter = (config && config.tokenGetter) || function () {};\n  }\n\n  public urlBase64Decode(str: string): string {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n    switch (output.length % 4) {\n      case 0: {\n        break;\n      }\n      case 2: {\n        output += '==';\n        break;\n      }\n      case 3: {\n        output += '=';\n        break;\n      }\n      default: {\n        throw new Error('Illegal base64url string!');\n      }\n    }\n    return this.b64DecodeUnicode(output);\n  }\n\n  // credits for decoder goes to https://github.com/atk\n  private b64decode(str: string): string {\n    const chars =\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    let output = '';\n\n    str = String(str).replace(/=+$/, '');\n\n    if (str.length % 4 === 1) {\n      throw new Error(\n        `'atob' failed: The string to be decoded is not correctly encoded.`\n      );\n    }\n\n    for (\n      // initialize result and counters\n      let bc = 0, bs: any, buffer: any, idx = 0;\n      // get next character\n      (buffer = str.charAt(idx++));\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer &&\n      ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n      // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4)\n        ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n        : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  }\n\n  private b64DecodeUnicode(str: any) {\n    return decodeURIComponent(\n      Array.prototype.map\n        .call(this.b64decode(str), (c: any) => {\n          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join('')\n    );\n  }\n\n  public decodeToken<T = any>(token: string): T | null;\n  public decodeToken<T = any>(token: Promise<string>): Promise<T | null>;\n  public decodeToken<T = any>(): null | T | Promise<T | null>;\n  public decodeToken<T = any>(token: string | Promise<string> = this.tokenGetter()): null | T | Promise<T | null> {\n    if (token instanceof Promise) {\n      return token.then(t => this._decodeToken(t));\n    }\n\n    return this._decodeToken(token);\n  }\n\n  private _decodeToken<T = any>(token: string): null | T  {\n    if (!token || token === '') {\n      return null;\n    }\n\n    const parts = token.split('.');\n\n    if (parts.length !== 3) {\n      throw new Error(\n        `The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.`\n      );\n    }\n\n    const decoded = this.urlBase64Decode(parts[1]);\n    if (!decoded) {\n      throw new Error('Cannot decode the token.');\n    }\n\n    return JSON.parse(decoded);\n  }\n\n  public getTokenExpirationDate(token: string): Date | null;\n  public getTokenExpirationDate(token: Promise<string>): Promise<Date | null>;\n  public getTokenExpirationDate(): null | Date | Promise<Date | null>;\n  public getTokenExpirationDate(\n    token: string | Promise<string> = this.tokenGetter()\n  ): Date | null | Promise<Date | null> {\n    if (token instanceof Promise) {\n      return token.then(t => this._getTokenExpirationDate(t));\n    }\n\n    return this._getTokenExpirationDate(token);\n  }\n\n  private _getTokenExpirationDate(token: string): Date | null {\n    let decoded: any;\n    decoded = this.decodeToken(token);\n\n    if (!decoded || !decoded.hasOwnProperty('exp')) {\n      return null;\n    }\n\n    const date = new Date(0);\n    date.setUTCSeconds(decoded.exp);\n\n    return date;\n  }\n\n  public isTokenExpired(token?: undefined, offsetSeconds?: number): boolean | Promise<boolean>;\n  public isTokenExpired(token: string | null, offsetSeconds?: number): boolean;\n  public isTokenExpired(token: Promise<string>, offsetSeconds?: number): Promise<boolean>;\n  public isTokenExpired(\n    token: undefined | null | string | Promise<string> = this.tokenGetter(),\n    offsetSeconds?: number\n  ): boolean | Promise<boolean> {\n    if (token instanceof Promise) {\n      return token.then(t => this._isTokenExpired(t, offsetSeconds));\n    }\n\n    return this._isTokenExpired(token, offsetSeconds);\n  }\n\n  private _isTokenExpired(\n    token: string | null,\n    offsetSeconds?: number\n  ): boolean {\n    if (!token || token === '') {\n      return true;\n    }\n    const date = this.getTokenExpirationDate(token);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (date === null) {\n      return false;\n    }\n\n    return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n  }\n\n  public getAuthScheme(\n    authScheme: Function | string | undefined,\n    request: HttpRequest<any>\n  ): string | undefined {\n    if (typeof authScheme === 'function') {\n      return authScheme(request);\n    }\n\n    return authScheme;\n  }\n}\n", "import { Injectable, Inject } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n} from '@angular/common/http';\nimport { DOCUMENT } from '@angular/common';\nimport { JwtHelperService } from './jwthelper.service';\nimport { JWT_OPTIONS } from './jwtoptions.token';\n\nimport { map, mergeMap } from 'rxjs/operators';\nimport { defer, from, Observable, of } from 'rxjs';\n\nconst fromPromiseOrValue = <T>(input: T | Promise<T>) => {\n  if (input instanceof Promise) {\n    return defer(() => input);\n  }\n  return of(input);\n};\n@Injectable()\nexport class JwtInterceptor implements HttpInterceptor {\n  tokenGetter: (\n    request?: HttpRequest<any>\n  ) => string | null | Promise<string | null>;\n  headerName: string;\n  authScheme: string | ((request?: HttpRequest<any>) => string);\n  allowedDomains: Array<string | RegExp>;\n  disallowedRoutes: Array<string | RegExp>;\n  throwNoTokenError: boolean;\n  skipWhenExpired: boolean;\n  standardPorts: string[] = ['80', '443'];\n\n  constructor(\n    @Inject(JWT_OPTIONS) config: any,\n    public jwtHelper: JwtHelperService,\n    @Inject(DOCUMENT) private document: Document\n  ) {\n    this.tokenGetter = config.tokenGetter;\n    this.headerName = config.headerName || 'Authorization';\n    this.authScheme =\n      config.authScheme || config.authScheme === ''\n        ? config.authScheme\n        : 'Bearer ';\n    this.allowedDomains = config.allowedDomains || [];\n    this.disallowedRoutes = config.disallowedRoutes || [];\n    this.throwNoTokenError = config.throwNoTokenError || false;\n    this.skipWhenExpired = config.skipWhenExpired;\n  }\n\n  isAllowedDomain(request: HttpRequest<any>): boolean {\n    const requestUrl: URL = new URL(request.url, this.document.location.origin);\n\n    // If the host equals the current window origin,\n    // the domain is allowed by default\n    if (requestUrl.host === this.document.location.host) {\n      return true;\n    }\n\n    // If not the current domain, check the allowed list\n    const hostName = `${requestUrl.hostname}${\n      requestUrl.port && !this.standardPorts.includes(requestUrl.port)\n        ? ':' + requestUrl.port\n        : ''\n    }`;\n\n    return (\n      this.allowedDomains.findIndex((domain) =>\n        typeof domain === 'string'\n          ? domain === hostName\n          : domain instanceof RegExp\n          ? domain.test(hostName)\n          : false\n      ) > -1\n    );\n  }\n\n  isDisallowedRoute(request: HttpRequest<any>): boolean {\n    const requestedUrl: URL = new URL(\n      request.url,\n      this.document.location.origin\n    );\n\n    return (\n      this.disallowedRoutes.findIndex((route: string | RegExp) => {\n        if (typeof route === 'string') {\n          const parsedRoute: URL = new URL(\n            route,\n            this.document.location.origin\n          );\n          return (\n            parsedRoute.hostname === requestedUrl.hostname &&\n            parsedRoute.pathname === requestedUrl.pathname\n          );\n        }\n\n        if (route instanceof RegExp) {\n          return route.test(request.url);\n        }\n\n        return false;\n      }) > -1\n    );\n  }\n\n  handleInterception(\n    token: string | null,\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ) {\n    const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n\n    if (!token && this.throwNoTokenError) {\n      throw new Error('Could not get token from tokenGetter function.');\n    }\n\n    let tokenIsExpired = of(false);\n\n    if (this.skipWhenExpired) {\n      tokenIsExpired = token ? fromPromiseOrValue(this.jwtHelper.isTokenExpired(token)) : of(true);\n    }\n\n    if (token) {\n      return tokenIsExpired.pipe(\n        map((isExpired) =>\n          isExpired && this.skipWhenExpired\n            ? request.clone()\n            : request.clone({\n                setHeaders: {\n                  [this.headerName]: `${authScheme}${token}`,\n                },\n              })\n        ),\n        mergeMap((innerRequest) => next.handle(innerRequest))\n      );\n    }\n\n    return next.handle(request);\n  }\n\n  intercept(\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n      return next.handle(request);\n    }\n    const token = this.tokenGetter(request);\n\n    return fromPromiseOrValue(token).pipe(\n      mergeMap((asyncToken: string | null) => {\n        return this.handleInterception(asyncToken, request, next);\n      })\n    );\n  }\n}\n", "import {\n  NgModule,\n  ModuleWithProviders,\n  Optional,\n  SkipSelf,\n  Provider,\n} from '@angular/core';\nimport { HttpRequest, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { JwtInterceptor } from './jwt.interceptor';\nimport { JWT_OPTIONS } from './jwtoptions.token';\nimport { JwtHelperService } from './jwthelper.service';\n\nexport interface JwtConfig {\n  tokenGetter?: (\n    request?: HttpRequest<any>\n  ) => string | null | Promise<string | null>;\n  headerName?: string;\n  authScheme?: string | ((request?: HttpRequest<any>) => string);\n  allowedDomains?: Array<string | RegExp>;\n  disallowedRoutes?: Array<string | RegExp>;\n  throwNoTokenError?: boolean;\n  skipWhenExpired?: boolean;\n}\n\nexport interface JwtModuleOptions {\n  jwtOptionsProvider?: Provider;\n  config?: JwtConfig;\n}\n\n@NgModule()\nexport class JwtModule {\n  constructor(@Optional() @SkipSelf() parentModule: JwtModule) {\n    if (parentModule) {\n      throw new Error(\n        `JwtModule is already loaded. It should only be imported in your application's main module.`\n      );\n    }\n  }\n  static forRoot(options: JwtModuleOptions): ModuleWithProviders<JwtModule> {\n    return {\n      ngModule: JwtModule,\n      providers: [\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: JwtInterceptor,\n          multi: true,\n        },\n        options.jwtOptionsProvider || {\n          provide: JWT_OPTIONS,\n          useValue: options.config,\n        },\n        JwtHelperService,\n      ],\n    };\n  }\n}\n", "/*\n * Public API Surface of angular-jwt\n */\n\nexport * from './lib/jwt.interceptor';\nexport * from './lib/jwthelper.service';\nexport * from './lib/jwtoptions.token';\nexport * from './lib/angular-jwt.module';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;IAEaA,cAAc,IAAIC,eAAe,aAAa;ICK9CC,yBAAgB;EAG3BC,YAAiCC,SAAc,MAAI;AACjD,SAAKC,cAAeD,UAAUA,OAAOC,eAAgB,WAAA;IAAA;;EAGhDC,gBAAgBC,KAAW;AAChC,QAAIC,SAASD,IAAIE,QAAQ,MAAM,GAAG,EAAEA,QAAQ,MAAM,GAAG;AACrD,YAAQD,OAAOE,SAAS,GAAC;MACvB,KAAK,GAAG;AACN;MACD;MACD,KAAK,GAAG;AACNF,kBAAU;AACV;MACD;MACD,KAAK,GAAG;AACNA,kBAAU;AACV;MACD;MACD,SAAS;AACP,cAAM,IAAIG,MAAM,2BAA2B;MAC5C;IACF;AACD,WAAO,KAAKC,iBAAiBJ,MAAM;;;EAI7BK,UAAUN,KAAW;AAC3B,UAAMO,QACJ;AACF,QAAIN,SAAS;AAEbD,UAAMQ,OAAOR,GAAG,EAAEE,QAAQ,OAAO,EAAE;AAEnC,QAAIF,IAAIG,SAAS,MAAM,GAAG;AACxB,YAAM,IAAIC,MACR,mEAAmE;IAEtE;AAED;UAEMK,KAAK,GAAGC,IAASC,QAAaC,MAAM;;MAEvCD,SAASX,IAAIa,OAAOD,KAAK;;MAE1B,CAACD,WACCD,KAAKD,KAAK,IAAIC,KAAK,KAAKC,SAASA;;MAGnCF,OAAO,KACFR,UAAUO,OAAOM,aAAa,MAAOJ,OAAQ,KAAKD,KAAM,EAAG,IAC5D;MACJ;AAEAE,eAASJ,MAAMQ,QAAQJ,MAAM;IAC9B;AACD,WAAOV;;EAGDI,iBAAiBL,KAAQ;AAC/B,WAAOgB,mBACLC,MAAMC,UAAUC,IACbC,KAAK,KAAKd,UAAUN,GAAG,GAAIqB,OAAU;AACpC,aAAO,OAAO,OAAOA,EAAEC,WAAW,CAAC,EAAEC,SAAS,EAAE,GAAGC,MAAM,EAAE;IAC7D,CAAC,EACAC,KAAK,EAAE,CAAC;;EAORC,YAAqBC,QAAkC,KAAK7B,YAAW,GAAE;AAC9E,QAAI6B,iBAAiBC,SAAS;AAC5B,aAAOD,MAAME,KAAKC,OAAK,KAAKC,aAAaD,CAAC,CAAC;IAC5C;AAED,WAAO,KAAKC,aAAaJ,KAAK;;EAGxBI,aAAsBJ,OAAa;AACzC,QAAI,CAACA,SAASA,UAAU,IAAI;AAC1B,aAAO;IACR;AAED,UAAMK,QAAQL,MAAMM,MAAM,GAAG;AAE7B,QAAID,MAAM7B,WAAW,GAAG;AACtB,YAAM,IAAIC,MACR,wHAAwH;IAE3H;AAED,UAAM8B,UAAU,KAAKnC,gBAAgBiC,MAAM,CAAC,CAAC;AAC7C,QAAI,CAACE,SAAS;AACZ,YAAM,IAAI9B,MAAM,0BAA0B;IAC3C;AAED,WAAO+B,KAAKC,MAAMF,OAAO;;EAMpBG,uBACLV,QAAkC,KAAK7B,YAAW,GAAE;AAEpD,QAAI6B,iBAAiBC,SAAS;AAC5B,aAAOD,MAAME,KAAKC,OAAK,KAAKQ,wBAAwBR,CAAC,CAAC;IACvD;AAED,WAAO,KAAKQ,wBAAwBX,KAAK;;EAGnCW,wBAAwBX,OAAa;AAC3C,QAAIO;AACJA,cAAU,KAAKR,YAAYC,KAAK;AAEhC,QAAI,CAACO,WAAW,CAACA,QAAQK,eAAe,KAAK,GAAG;AAC9C,aAAO;IACR;AAED,UAAMC,OAAO,oBAAIC,KAAK,CAAC;AACvBD,SAAKE,cAAcR,QAAQS,GAAG;AAE9B,WAAOH;;EAMFI,eACLjB,QAAqD,KAAK7B,YAAW,GACrE+C,eAAsB;AAEtB,QAAIlB,iBAAiBC,SAAS;AAC5B,aAAOD,MAAME,KAAKC,OAAK,KAAKgB,gBAAgBhB,GAAGe,aAAa,CAAC;IAC9D;AAED,WAAO,KAAKC,gBAAgBnB,OAAOkB,aAAa;;EAG1CC,gBACNnB,OACAkB,eAAsB;AAEtB,QAAI,CAAClB,SAASA,UAAU,IAAI;AAC1B,aAAO;IACR;AACD,UAAMa,OAAO,KAAKH,uBAAuBV,KAAK;AAC9CkB,oBAAgBA,iBAAiB;AAEjC,QAAIL,SAAS,MAAM;AACjB,aAAO;IACR;AAED,WAAO,EAAEA,KAAKO,QAAO,KAAK,oBAAIN,KAAI,GAAGM,QAAO,IAAKF,gBAAgB;;EAG5DG,cACLC,YACAC,SAAyB;AAEzB,QAAI,OAAOD,eAAe,YAAY;AACpC,aAAOA,WAAWC,OAAO;IAC1B;AAED,WAAOD;;;AA1KEtD,iBAAAwD,OAAA,SAAAC,yBAAAtB,GAAA;AAAA,SAAA,KAAAA,KAAAnC,kBAAA0D,SAGS5D,WAAW,CAAA;AAAA;yBAHpB6D,mBAAA;EAAA3B,OAAAhC;EAAgB4D,SAAhB5D,iBAAgBwD;AAAA,CAAA;;qDAAhBK,iBAAA7D,kBAAgB,CAAA;UAD5B8D;;;;;cAIcC;eAAOjE,WAAW;;;;;ACIjC,IAAMkE,qBAAyBC,WAAyB;AACtD,MAAIA,iBAAiBhC,SAAS;AAC5B,WAAOiC,MAAM,MAAMD,KAAK;EACzB;AACD,SAAOE,GAAGF,KAAK;AACjB;IAEaG,uBAAc;EAYzBnE,YACuBC,QACdmE,WACmBC,UAAkB;AADrC,SAASD,YAATA;AACmB,SAAQC,WAARA;AAL5B,SAAAC,gBAA0B,CAAC,MAAM,KAAK;AAOpC,SAAKpE,cAAcD,OAAOC;AAC1B,SAAKqE,aAAatE,OAAOsE,cAAc;AACvC,SAAKlB,aACHpD,OAAOoD,cAAcpD,OAAOoD,eAAe,KACvCpD,OAAOoD,aACP;AACN,SAAKmB,iBAAiBvE,OAAOuE,kBAAkB,CAAA;AAC/C,SAAKC,mBAAmBxE,OAAOwE,oBAAoB,CAAA;AACnD,SAAKC,oBAAoBzE,OAAOyE,qBAAqB;AACrD,SAAKC,kBAAkB1E,OAAO0E;;EAGhCC,gBAAgBtB,SAAyB;AACvC,UAAMuB,aAAkB,IAAIC,IAAIxB,QAAQyB,KAAK,KAAKV,SAASW,SAASC,MAAM;AAI1E,QAAIJ,WAAWK,SAAS,KAAKb,SAASW,SAASE,MAAM;AACnD,aAAO;IACR;AAGD,UAAMC,WAAc,GAAAN,WAAWO,QAAQ,GACrCP,WAAWQ,QAAQ,CAAC,KAAKf,cAAcgB,SAAST,WAAWQ,IAAI,IAC3D,MAAMR,WAAWQ,OACjB,EACN;AAEA,WACE,KAAKb,eAAee,UAAWC,YAC7B,OAAOA,WAAW,WACdA,WAAWL,WACXK,kBAAkBC,SAClBD,OAAOE,KAAKP,QAAQ,IACpB,KAAK,IACP;;EAIRQ,kBAAkBrC,SAAyB;AACzC,UAAMsC,eAAoB,IAAId,IAC5BxB,QAAQyB,KACR,KAAKV,SAASW,SAASC,MAAM;AAG/B,WACE,KAAKR,iBAAiBc,UAAWM,WAA0B;AACzD,UAAI,OAAOA,UAAU,UAAU;AAC7B,cAAMC,cAAmB,IAAIhB,IAC3Be,OACA,KAAKxB,SAASW,SAASC,MAAM;AAE/B,eACEa,YAAYV,aAAaQ,aAAaR,YACtCU,YAAYC,aAAaH,aAAaG;MAEzC;AAED,UAAIF,iBAAiBJ,QAAQ;AAC3B,eAAOI,MAAMH,KAAKpC,QAAQyB,GAAG;MAC9B;AAED,aAAO;IACT,CAAC,IAAI;;EAITiB,mBACEjE,OACAuB,SACA2C,MAAiB;AAEjB,UAAM5C,aAAa,KAAKe,UAAUhB,cAAc,KAAKC,YAAYC,OAAO;AAExE,QAAI,CAACvB,SAAS,KAAK2C,mBAAmB;AACpC,YAAM,IAAIlE,MAAM,gDAAgD;IACjE;AAED,QAAI0F,iBAAiBhC,GAAG,KAAK;AAE7B,QAAI,KAAKS,iBAAiB;AACxBuB,uBAAiBnE,QAAQgC,mBAAmB,KAAKK,UAAUpB,eAAejB,KAAK,CAAC,IAAImC,GAAG,IAAI;IAC5F;AAED,QAAInC,OAAO;AACT,aAAOmE,eAAeC,KACpB5E,IAAK6E,eACHA,aAAa,KAAKzB,kBACdrB,QAAQ+C,MAAK,IACb/C,QAAQ+C,MAAM;QACZC,YAAY;UACV,CAAC,KAAK/B,UAAU,GAAM,GAAAlB,UAAa,GAAAtB,KAAO;QAC3C;MACF,CAAA,CAAC,GAERwE,SAAUC,kBAAiBP,KAAKQ,OAAOD,YAAY,CAAC,CAAC;IAExD;AAED,WAAOP,KAAKQ,OAAOnD,OAAO;;EAG5BoD,UACEpD,SACA2C,MAAiB;AAEjB,QAAI,CAAC,KAAKrB,gBAAgBtB,OAAO,KAAK,KAAKqC,kBAAkBrC,OAAO,GAAG;AACrE,aAAO2C,KAAKQ,OAAOnD,OAAO;IAC3B;AACD,UAAMvB,QAAQ,KAAK7B,YAAYoD,OAAO;AAEtC,WAAOS,mBAAmBhC,KAAK,EAAEoE,KAC/BI,SAAUI,gBAA6B;AACrC,aAAO,KAAKX,mBAAmBW,YAAYrD,SAAS2C,IAAI;KACzD,CAAC;;;;mBAnIK9B,gBDdAV,SC2BD5D,WAAW,GD3BV4D,SC2BU1D,gBAAA,GD3BV0D,SC6BDmD,QAAQ,CAAA;AAAA;uBD7BPlD,mBAAA;EAAA3B,OCcAoC;EAAcR,SAAdQ,eAAcZ;AAAA,CAAA;;qDDddK,iBCcAO,gBAAc,CAAA;UAD1BN;;;;;cAcIC;eAAOjE,WAAW;;;;;;;cAElBiE;eAAO8C,QAAQ;;;;;ICNPC,kBAAAA,WAAS;EACpB7G,YAAoC8G,cAAuB;AACzD,QAAIA,cAAc;AAChB,YAAM,IAAItG,MACR,4FAA4F;IAE/F;;EAEH,OAAOuG,QAAQC,SAAyB;AACtC,WAAO;MACLC,UAAUJ;MACVK,WAAW,CACT;QACEC,SAASC;QACTC,UAAUlD;QACVmD,OAAO;MACR,GACDN,QAAQO,sBAAsB;QAC5BJ,SAAStH;QACT2H,UAAUR,QAAQ/G;MACnB,GACDF,gBAAgB;;;;;mBArBX8G,WFvBApD,SEuBSoD,WAAA,EAAA,CAAA;AAAA;iBFvBTY,iBAAA;EAAAC,MEuBAb;AAAS,CAAA;iBFvBTc,iBAAA,CAAA,CAAA;;qDAAA/D,iBEuBAiD,WAAS,CAAA;UADrBe;;;;;cAEcC;;cAAYC;;;;;",
  "names": ["JWT_OPTIONS", "InjectionToken", "JwtHelperService", "constructor", "config", "tokenGetter", "urlBase64Decode", "str", "output", "replace", "length", "Error", "b64DecodeUnicode", "b64decode", "chars", "String", "bc", "bs", "buffer", "idx", "charAt", "fromCharCode", "indexOf", "decodeURIComponent", "Array", "prototype", "map", "call", "c", "charCodeAt", "toString", "slice", "join", "decodeToken", "token", "Promise", "then", "t", "_decodeToken", "parts", "split", "decoded", "JSON", "parse", "getTokenExpirationDate", "_getTokenExpirationDate", "hasOwnProperty", "date", "Date", "setUTCSeconds", "exp", "isTokenExpired", "offsetSeconds", "_isTokenExpired", "valueOf", "getAuthScheme", "authScheme", "request", "ɵfac", "JwtHelperService_Factory", "ɵɵinject", "ɵɵdefineInjectable", "factory", "ɵsetClassMetadata", "Injectable", "Inject", "fromPromiseOrValue", "input", "defer", "of", "JwtInterceptor", "jwtHelper", "document", "standardPorts", "headerName", "allowedDomains", "disallowedRoutes", "throwNoTokenError", "skipWhenExpired", "isAllowedDomain", "requestUrl", "URL", "url", "location", "origin", "host", "hostName", "hostname", "port", "includes", "findIndex", "domain", "RegExp", "test", "isDisallowedRoute", "requestedUrl", "route", "parsedRoute", "pathname", "handleInterception", "next", "tokenIsExpired", "pipe", "isExpired", "clone", "setHeaders", "mergeMap", "innerRequest", "handle", "intercept", "asyncToken", "DOCUMENT", "JwtModule", "parentModule", "forRoot", "options", "ngModule", "providers", "provide", "HTTP_INTERCEPTORS", "useClass", "multi", "jwtOptionsProvider", "useValue", "ɵɵdefineNgModule", "type", "ɵɵdefineInjector", "NgModule", "Optional", "SkipSelf"]
}
